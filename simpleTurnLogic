"""
Simple interpretation of turn and distance
"""

#Logic should also work with UTM if we get Lat/Long-UTM converter to work
#Easier to think of turns in UTM system, based on turn-logic
#file -> list of tuples. each tuple has latitude, longitude, time
#covert all latitude, longitude pairs to UTM? or not necessarily

"""
how to determine turns:
Case 1: previous easting decreases, TURN, northing decreases = LEFT TURN
Case 2: previous easting decreases, TURN, northing increases = RIGHT TURN
Case 3: previous easting increases, TURN, northing decreases = RIGHT TURN
Case 4: previous easting increases, TURN, northing increases = LEFT TURN 

Case 5: previous northing decreases, TURN, easting increases = RIGHT TURN
Case 6: previous northing decreases, TURN, easting decreases = LEFT TURN
Case 7: previous northing increases, TURN, easting decrease = LEFT TURN
Case 8: previous northing increases, TURN, easting increases = RIGHT TURN  
   """
"""
how to determine segment: 
one coordinate is primarily changing while the other is primarily staying the same
which direction?
Case 1: easting same between point 1, 2, etc; northing increasing - 
Case 2: easting same between point 1, 2 etc; northing decreasing
Case 3: easting increasing between 1, 2, 3+; northing same
Case 4: easting decreasing between 1, 2, 3+; northing same 
How to define same: deviation by .5 meter? 1 meter is about 39.4 inches.
If each trackpoint is 1 second, then 20 inches of minor-axis variation in one second seems about enough? 
"Same" is not really the same but per segment, one axis has a lot less variation than the other axis
.5 meter, or any measurement in terms of meters, is easy to work with UTM
"""

 """ loop might need?
 #most of them it does not really need
segmentCount
segmentFirstPoint
segmentLastPoint
waverLimit
isMovementAlongEasting
isMovementAlongNorthing
netdifferenceMajorAxis
highestValueMinorAxis
lowestValueMajorAxis
differenceHighestToLowestMinorAxis
thisPointIsTurn (long, lat)
latDiffGreater
longDiffGreater
countLatDiffGreater
countLongDiffGreater
latDiffTotal
longDiffTotal
"""
#function returns the difference of the two points on the axis of greater difference for those 2 points
#That will determine the direction of the segment
#so the distance of that segment will stop when axis of greater difference changes after a turn
def compareAxes(point1, point2):
    latDiff =point2.lat - point1.lat
    longDiff = point2.long - point1.long
    #absolute value for longitude?
    greaterDiff = (max(latDiff, longDiff))
    if greaterDiff == latDiff:
        return latDiff
    elif greaterDiff == longDiff:
        return longDiff
    else: # latDifference and longDifference are equal
        return 0

def differencesOnSegment():
    while(pointA.isTurn== False):
        compare (pointA, pointB)
        if compare(pointA, pointB) == compare(pointA, pointB).latDiff:
            totalLatDiff += compare(pointA, pointB)
        if compare(pointA, pointB) == compare(pointA, pointB).longDiff:
            totalLongDiff += compare(pointA, pointB)
    #when loop stops
    if(totalLatDiff > totalLongDiff):
        return "vertical"
    if (totalLongDiff > totalLatDiff):
        return "horizontal"

def pointIsTurn(point1, point2, point3, point4, point5):
    #Case1
    if (point1.long > point2.long):  # 2 points have same-ish latitude, 2nd point has less longitude
        if (point2.lat == point3.lat & point3.long < point2.long): #point2 and point3 have same latitude, point 3 has less longitude
            #make turn on point3, so point 4 has same longitude but lower latitude
            if (point3.lat > point4.lat): # turning downward
                if (point4.long == point3.long & point3.lat > point4.lat):
                    #if(point5.long == point4.long && point4.lat > point5.lat)
                    # case1
                    point3.isTurn = True
                    point3.turnDirection = "Left"
            #case 2
            if (point3.lat < point4.lat): #turning upward
                if (point4.long == point3.long & point3.lat < point4.lat):
                    point3.isTurn = True
                    point3.turnDirection = "Right"
    #Case 3
    if (point1.long < point2.long): #eastiness of longitude increases
        if (point2.lat == point3.lat & point3.long > point2.long):
            if(point3.lat > point4.lat): #turning downward
                if (point4.long == point3.long & point3.lat > point4.lat):
                    #if(point5.long == point4.long & point4.lat > point5.lat)
                    point3.isTurn = True
                    point3.turnDirection = "Left"
    #Case 4
            if(point3.lat < point4.lat): #turning upward
                if (point4.long == point3.long & point3.lat< point4.lat):
                    #if (point5.long == point4.long & point4.lat < point5.lat)
                    point3.isTurn = True
                    point3.turnDirection = "Left"

    # Case 5
    if ( point2.lat < point1.lat): #northing decreasing
        if(point3.lat < point2.lat & point3.long == point2.long):
            if (point4.long > point3.long & point4.lat == point3.lat):
                #if (point5.long > point4.long & point5.lat == point4.lat )
                point3.isTurn = True
                point3.turnDirection = "Right"
        #Case 6
        if(point3.lat < point2.lat & point3.long == point2.long):
            if (point4.long < point3.long & point4.lat == point3.lat):
                #if(point5.long < point4.long & point5.lat == point4.lat)
                point3.isTurn = True
                point3.turnDirection = "Left"
    #Case 7
    if(point1.lat < point2.lat): #northing increasing
        if(point3.lat > point2.lat & point2.long == point3.long):
            if(point4.long < point3.long & point4.lat == point3.lat):
                #if (point5.long < point4.long & point4.lat == point5.lat)
                point3.isTurn == "True"
                point3.turnDirection = "Left"
            #Case 8
            if(point4.long > point3.long & point4.lat == point3.lat):
                point3.isTurn == "True"
                point3.turnDirection = "Right"

#Figure out where segment starts, ends, and segment's distance in a certain direction
# apply to all segments of track
#possible exceptions of segments that have less than 4 points that wouldn't work with this turning logic?


